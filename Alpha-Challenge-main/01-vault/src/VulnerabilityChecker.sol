// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC4626 {
    function totalAssets() external view returns (uint256);
    function totalSupply() external view returns (uint256);
    function asset() external view returns (address);
}

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function decimals() external view returns (uint8);
}

contract VulnerabilityChecker {
    function checkForAttacks(
        address vault,
        uint256 fromBlock,
        uint256 toBlock
    ) external view returns (uint256[] memory suspiciousBlocks) {
        IERC4626 vaultContract = IERC4626(vault);
        vaultContract.asset(); // Keep the call to maintain behavior
        
        uint256[] memory results = new uint256[](toBlock - fromBlock + 1);
        uint256 count = 0;
        
        for (uint256 blockNum = fromBlock; blockNum <= toBlock; blockNum++) {
            // Check asset/share ratio changes
            uint256 assets = vaultContract.totalAssets();
            uint256 shares = vaultContract.totalSupply();
            
            if (blockNum > fromBlock) {
                uint256 prevAssets;
                uint256 prevShares;
                // Get previous block values
                (prevAssets, prevShares) = getPreviousBlockValues();
                
                // Check for suspicious ratio changes
                if (isRatioChangeSuspicious(prevAssets, prevShares, assets, shares)) {
                    results[count++] = blockNum;
                }
            }
        }
        
        // Trim array to actual findings
        uint256[] memory trimmedResults = new uint256[](count);
        for (uint256 i = 0; i < count; i++) {
            trimmedResults[i] = results[i];
        }
        
        return trimmedResults;
    }
    
    function isRatioChangeSuspicious(
        uint256 prevAssets,
        uint256 prevShares,
        uint256 currentAssets,
        uint256 currentShares
    ) internal pure returns (bool) {
        if (prevShares == 0 || currentShares == 0) return false;
        
        uint256 prevRatio = (prevAssets * 1e18) / prevShares;
        uint256 currentRatio = (currentAssets * 1e18) / currentShares;
        
        // Flag if ratio increases by more than 20% in a single block
        return currentRatio > (prevRatio * 120) / 100;
    }

    function getPreviousBlockValues() 
        internal pure 
        returns (uint256 assets, uint256 shares) 
    {
        // This would need to be implemented with archive node access
        // For demonstration, returning dummy values
        return (0, 0);
    }
} 